GOing to WASM?
Should we be excited? What is possible?

18 Oct 2018

Max Gonzih

[[https://gonzih.me][gonzih.me]]
gonzih@gmail.com
@Gonzih

* What is WASM?

.html tweaks.html

.image webassembly.svg _ 800

* What is WASM?
- binary instruction format
- stack-based VM
- targeting web and server side deployments

* Why does it matter?

- less JavaScript on the Web
- less transpilers
- almost native level of performance

* Possibilities

Using WebAssembly on a serverless platform

[[https://blog.cloudflare.com/webassembly-on-cloudflare-workers/][https://blog.cloudflare.com/webassembly-on-cloudflare-workers/]]

.image cloudflareworkers.png

* Possibilities

Kernel-space WebAssembly Runtime for Linux

[[https://github.com/rianhunter/wasmjit][https://github.com/rianhunter/wasmjit]]

.image wasmjit.png

* Running Go on WASM

- Available since 1.11
- Adds `GOOS=js` and `GOARCH=wasm` variables to the compiler
- Interop is implemented using `syscall/js` package

.image packagejs.png

* Getting JS helper

  curl https://raw.githubusercontent.com/golang/go/go1.11/misc/wasm/wasm_exec.js > wasm_exec.js

Or

  cp $GOSRC/misc/wasm/wasm_exec.js wasm_exec.js

* JS helper

`wasm_exec.js`

- Unifies Node.js and browser WASM APIs in to one JS object called Go
- Sets up JS -> Go interop

  const setInt64 = (addr, v) => {
    mem().setUint32(addr + 0, v, true);
    mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);
  }

* JS helper

`wasm_exec.js`

- Sets up funcs from `syscall/js` pagkage on Go side

  // func valueGet(v ref, p string) ref
  "syscall/js.valueGet": (sp) => {
    storeValue(sp + 32, Reflect.get(loadValue(sp + 8), loadString(sp + 16)));
  },


* Getting HTML template

  curl https://raw.githubusercontent.com/golang/go/go1.11/misc/wasm/wasm_exec.html > wasm_exec.html

Or

  cp $GOSRC/misc/wasm/wasm_exec.html wasm_exec.html

* Getting HTML template

`wash_exec.html` Demonstrates how to put this together

- on JS side

  const go = new Go();
  ...
  WebAssembly.instantiateStreaming(...).then((result) => {
      mod = result.module;
      inst = result.instance;

  });

  async function run() {
    await go.run(inst);
    ...
  }

- and HTML side

  <button onClick="run();" id="runButton" disabled>Run</button>

* Hello World time

  package main

  import "syscall/js"

  func main() {
    js.Global().Call("alert", "Hello Wasm!")
  }

* Compiling it

  GOARCH=wasm GOOS=js go build -o test.wasm

* Running it

Well, *test.wasm* needs to be loaded with Content-Type header set to *application/wasm*

What shall we do?

* Let's put together a small file server

.code server.go

* DEMO

* The Future is here

.image wasm-corp.png _ 800


* Should we be excited?

Yes, but...

* But...

  $ l -lha test.wasm
  -rwxr-xr-x 1 gnzh gnzh 2.4M Sep 15 09:13 test.wasm*

* Why?

- WASM is a stack mahcine. Go has to maintain its own stack (GC)
- No GOTO instruction, so Go has to generate a huge switch statement to resume goroutines
- Binary size was not a priority for this release

More Information: [[https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/edit][WebAssembly architecture for GO]]

* Going crazy

What about creating reactive frontend frameworking in golang? How hard can it be?

[[https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5][Didact: a DIY guide to build your own React (JS)]]

* Use <template> tag as our templating solution

    <template id="rootTemplate">
        <div>
            <span :class="LabelClass">Clicked {{ Count }} times</span>
            <input type="button" value="â™¡" @click="ClickHandler"></input>
            <br/>
        </div>
    </template>

* State stored in Store

  type Store struct {
    store map[string]interface{}
  }

  func (s *Store) Set(k string, v interface{}) {
    ...
  }

  func (s *Store) Get(k string) interface{} {
    ...
  }

  func (s *Store) Subscribe(ch chan bool) {
    ...
  }


* Create a new component

  store := NewStore()

  methods := map[string]func(js.Value){
    "ClickHandler": func(event js.Value) {
      ...
    },
  }

  computed := map[string]func() string{
    "Counter": func() string {
      ...
    },
  }

  cmp := NewComponent("rootTemplate", methods, computed)
  store.Subscribe(cmp.notificationChan)
  cmp.MountTo("root")

* Computed properties

  computed := map[string]func() string{
    "Counter": func() string {
      return fmt.Sprintf("Clicked me %d times", store.Get("counter"))
    },
  }

* Component methods

  methods := map[string]func(js.Value){
    "ClickHandler": func(event js.Value) {
      c := store.Get("counter").(int)
      store.Set("counter", c+1)
    },
  }

* NewComponent function

  cmp := NewComponent("rootTemplate", methods, computed)

- Get template Inner HTML
- Parse HTML in to tree of elements

* Get template Inner HTML
  // JavaScript
  document.getElementById(templateID).innerHTML

  // Go
  js.Global().Get("document").Call("getElementById", templateID).Get("innerHTML").String()


* Parse HTML in to tree of elements
    r := strings.NewReader(templateData)
    z := html.NewTokenizer(r)

    tt := z.Next()
    switch {
    ...
    case tt == html.StartTagToken:
      el := &El{}
      el.Type = token.Data
      for _, attr := range token.Attr {
        ...
      }
    }

* Dynamic attributes

  for _, attr := range token.Attr {
    if strings.HasPrefix(attr.Key, ":") {
      element.Attr = append(
        element.Attr,
        &DynamicAttribute{
          K:  strings.Replace(attr.Key, ":", "", 1),
          Fn: handler,
        })
    }

  }

* Event handlers

  for _, attr := range token.Attr {
    if strings.HasPrefix(attr.Key, "@") {
      // handle event callback
      callback := js.NewEventCallback(js.PreventDefault, method)
      ...
    }
  }

* Handle text nodes

  case tt == html.TextToken:
    t := z.Token()
    child := &El{Type: TEXT_TYPE, NodeValue: t.Data}
    el.Children = append(parent.Children, child)

* Dynamic attributes in text nodes

  <span>This is a template for {{ Name }}</span>

  for k, fn := range c.Computed {
    re := regexp.MustCompile(fmt.Sprintf(`\{\{\s*%s\s*\}\}`, k))
    if re.MatchString(child.NodeValue) {
      at := &DynamicAttribute{
        K:  k,
        Fn: fn,
      }
      child.Attr = append(child.Attr, at)
    }
  }

* Attaching component to DOM

  cmp := NewComponent("rootTemplate", methods, computed)
  cmp.MountTo("root")

* Rendering Loop

  func (cmp *Component) MountTo(rootID string) {
    cmp.RenderTo(rootID)

    for range cmp.notificationChan {
      var cb js.Callback

      callback := js.NewCallback(func(_ []js.Value) {
        cmp.RenderTo(rootID)
        cb.Release()
      })

      js.Global().Get("window").Call("requestAnimationFrame", callback)
    }
  }

* window.requestAnimationFrame()

Tells the browser that you wish to perform an animation and requests that the browser call a specified function to update an animation before the next repaint.

* RenderTo function

  func (cmp *Component) RenderTo(rootID string) {
    changes := make([]Change, 0)
    vdom := component.RenderToVDom()
    vdom.Diff(component.OldVDom, &changes, rootID)
    ...

* Diff

- If no old version of VDOM is prenent -> gerenare CREATE Change
- Otherwise diff properties and create UPDATE Change

* Applying changes

  for _, change := range changes {
    change.Apply()
  }

* Applying changes

  func (ch *Change) Apply() {
    switch ch.Type {
    case "CREATE":
      ch.create()
    case "UPDATE":
      ch.update()
    }
  }

* CREATE change
  ch.parentNode.Call("appendChild", ch.domNode)

* UPDATE change
  for _, attrName := range ch.attributesToDelete {
    ch.domNode.Call("removeAttribute", attrName)
  }

  for _, attr := range ch.NewNode.Attr {
    log.Printf("setAttribute %s %s", attr.Key(), attr.Val())
    ch.domNode.Call("setAttribute", attr.Key(), attr.Val())
  }

* UPDATE change for text nodes

  if ch.NewNode.Tag == TEXT_TYPE {
    content := ch.NewNode.Data
    for _, attr := range ch.NewNode.Attr {
      re := regexp.MustCompile(fmt.Sprintf(`\{\{\s*%s\s*\}\}`, attr.Key()))
      content = re.ReplaceAllString(content, attr.Val())
    }

    ch.domNode.Set("textContent", content)
  }

* DEMO

* What is not there

- Nested components
- No branching in DSL (if-else)
- No loops in DSL
- This is just a demo :)

* Conclusion

Go on WASM

- It works
- It's not perfect
- Please give it a try!
- Yay!

# vim: ts=2:sts=2:sw=2:expandtab
