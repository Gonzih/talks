GOing to WASM?
Building a frontend framework in Go!

18 Oct 2018

Max Gonzih

[[//gonzih.me][gonzih.me]]
gonzih@gmail.com
@Gonzih

* What is WASM?

: who here knows what is web assembly?

* What is WASM?

- a standard that defines binary instruction format
- intended to be run on a stack machine
- faster to parse and execute than JavaScript
- can be used outside of the browser

.html tweaks.html

.image webassembly.svg _ 600

* Possibilities

Using WebAssembly on a serverless platform

[[https://blog.cloudflare.com/webassembly-on-cloudflare-workers/][blog.cloudflare.com/webassembly-on-cloudflare-workers/]]

.image cloudflareworkers.png

* Possibilities

Kernel-space WebAssembly Runtime for Linux

[[https://github.com/rianhunter/wasmjit][github.com/rianhunter/wasmjit]]

: runs WebAssembly modules in kernel-space
: provides access to system calls as normal function calls
: idea was to avoid user-kernel transition overhead
: WASM is already becoming new assembly format

.image wasmjit.png

* Go on WASM

* Why is this exciting?

- Go is great
- Go can be used to build web apps using existing ecosystem and tooling
- Sharing logic between backend and frontend
- Can target not just web browser

: server side language going to the frontend
: opposite direction compared to node.js for example

* Running Go on WASM

- Available since 1.11
- Adds `GOOS=js` and `GOARCH=wasm` variables to the compiler

  GOARCH=wasm GOOS=js go build -o test.wasm

- Interop is implemented using `syscall/js` package
.image packagejs.png

* Hello World time

  package main

  import "syscall/js"

  func main() {
    js.Global().Call("alert", "Hello Wasm!")
  }

: demo in hello-world folder
: pretty simple, isn't it?

* Getting JS and HTML helper files

Can be found in go source source tree under `misc/wasm` directory

  cp $GOSRC/misc/wasm/wasm_exec.js wasm_exec.js
  cp $GOSRC/misc/wasm/wasm_exec.html wasm_exec.html

* JS helper

`wasm_exec.js`

- Unifies Node.js and browser WASM APIs in to one JS object called Go
- Sets up JS -> Go interop

  const setInt64 = (addr, v) => {
    mem().setUint32(addr + 0, v, true);
    mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);
  }

- Defines funcs from `syscall/js` package from JS side

  // func valueGet(v ref, p string) ref
  "syscall/js.valueGet": (sp) => {
    storeValue(sp + 32, Reflect.get(loadValue(sp + 8), loadString(sp + 16)));
  },

* Running it

*test.wasm* needs to be served with Content-Type header set to *application/wasm*

  func wasmHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/wasm")
    http.ServeFile(w, r, "test.wasm")
  }

  func main() {
    mux := http.NewServeMux()
    mux.Handle("/", http.FileServer(http.Dir(".")))
    mux.HandleFunc("/test.wasm", wasmHandler)
    log.Fatal(http.ListenAndServe(":3000", mux))
  }

* The Future is here

.image wasm-corp.png _ 800

* It works!

Yes, but... file size ðŸ˜•

  $ l -lha test.wasm
  -rwxr-xr-x 1 gnzh gnzh 2.4M Sep 15 09:13 test.wasm*

: a lot for a binary format that suppose to be compact

* Why?

- WASM is a stack mahcine. Go has to maintain its own stack (GC)
- No GOTO instruction, so Go has to generate a huge switch statement to resume goroutines
- Binary size was not a priority for this release

More Information: [[https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/edit][WebAssembly architecture for GO]]

* Building a frontend framework

: who here actually used vue.js and/or react.js

* Reactive framework

  - DSL/Markup format
  - State managment
  - Component creation API
  -- Configure computed properties
  -- Configure event handlers

  - Generate tree of elements
  -- get template inner html
  -- parse html
  -- create dynamic attributes
  -- create event handlers
  -- handle text nodes

  - Attach component to DOM tree
  -- Start rendering loop
  --- Generate VDOM out of tree of elements
  --- Diff VDOM against previous version to generate changes
  --- Apply changes to the DOM tree

#[[https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5][Didact: a DIY guide to build your own React (JS)]]

* Makup format

    <template id="rootTemplate">
        <div>
            <span :class="LabelClass">Clicked {{ Count }} times</span>
            <input type="button" value="Click Me" @click="ClickHandler"></input>
        </div>
    </template>

- computed poperties
  :class="LabelClass" and {{ Count }}
- event handlers
  @click="ClickHandler"

: we have to define html of our components in some way
: in this example we are going to use <template> tag

* State managment

  type Store struct {
    store map[string]interface{}
  }

  func (s *Store) Set(k string, v interface{}) {
    // ...
  }

  func (s *Store) Get(k string) interface{} {
    // ...
  }

  func (s *Store) Subscribe(ch chan bool) {
    // ...
  }


* Component creation API

  store := NewStore()

  handlers := map[string]func(js.Value){
    "ClickHandler": func(event js.Value) {
      // ...
    },
  }

  computed := map[string]func() string{
    "Counter": func() string {
      // ...
    },
  }

  cmp := NewComponent("rootTemplate", handlers, computed)
  store.Subscribe(cmp.notificationChan)
  cmp.MountTo("root")

* Configure computed properties

  computed := map[string]func() string{
    "Counter": func() string {
      return fmt.Sprintf("Clicked me %d times", store.Get("counter"))
    },
  }

* Configure event handlers

  handlers := map[string]func(js.Value){
    "ClickHandler": func(event js.Value) {
      c := store.Get("counter").(int)
      store.Set("counter", c+1)
    },
  }
* Get template Inner HTML
  // Go
  js.Global().Get("document").Call("getElementById", templateID).Get("innerHTML").String()

  // JavaScript
  document.getElementById(templateID).innerHTML

* Parse HTML

    r := strings.NewReader(templateData)
    z := html.NewTokenizer(r)

    tt := z.Next()
    switch {
    case tt == html.StartTagToken:
      el := &El{}
      el.Type = token.Data
      for _, attr := range token.Attr {
        // ...
      }
      el.Children = parseChildren(el, z)
    }

* Dynamic attributes

  for _, attr := range token.Attr {
    if strings.HasPrefix(attr.Key, ":") {
      element.Attr = append(
        element.Attr,
        &DynamicAttribute{
          K:  strings.Replace(attr.Key, ":", "", 1),
          Fn: handler,
        })
    }

  }

* Event handlers

  for _, attr := range token.Attr {
    if strings.HasPrefix(attr.Key, "@") {
      callback := js.NewEventCallback(js.PreventDefault, method)
      // ...
    }
  }

* Handle text nodes

  case tt == html.TextToken:
    t := z.Token()
    child := &El{Type: TEXT_TYPE, NodeValue: t.Data}
    el.Children = append(parent.Children, child)

  // ...
  // <span>This is a template for {{ Name }}</span>

  for k, fn := range c.Computed {
    re := regexp.MustCompile(fmt.Sprintf(`\{\{\s*%s\s*\}\}`, k))
    if re.MatchString(child.NodeValue) {
      at := &DynamicAttribute{
        K:  k,
        Fn: fn,
      }
      child.Attr = append(child.Attr, at)
    }
  }


* Attaching component to DOM

  cmp := NewComponent("rootTemplate", methods, computed)
  cmp.MountTo("root")

* Start rendering Loop

  func (cmp *Component) MountTo(rootID string) {
    cmp.RenderTo(rootID)

    for range cmp.notificationChan {
      var cb js.Callback

      callback := js.NewCallback(func(_ []js.Value) {
        cmp.RenderTo(rootID)
        cb.Release()
      })

      js.Global().Get("window").Call("requestAnimationFrame", callback)
    }
  }

window.requestAnimationFrame()

Tells the browser that we wish to perform an animation and requests that the browser call a specified function before the next repaint.

* Diff VDOM against previous version

  func (cmp *Component) RenderTo(rootID string) {
    changes := make([]Change, 0)
    vdom := component.RenderToVDom()
    vdom.Diff(component.OldVDom, &changes, rootID)
    // ...

Diff logic
- CREATE change: If no old version of VDOM is prenent
- UPDATE change: otherwise diff properties

Diffing properties
- All properties that are not present in new VDOM need to be deleted
- All properties value of which has changed need to be updated

* Applying changes

  for _, ch := range changes {
    switch ch.Type {
    case "CREATE":
      ch.parentNode.Call("appendChild", ch.domNode)
    case "UPDATE":
      for _, attrName := range ch.attributesToDelete {
        ch.domNode.Call("removeAttribute", attrName)
      }

      for _, attr := range ch.attributesToUpdate {
        ch.domNode.Call("setAttribute", attr.Key(), attr.Val())
      }
    }
  }

* UPDATE change for text nodes

  if ch.NewNode.Tag == TEXT_TYPE {
    content := ch.NewNode.Data
    for _, attr := range ch.NewNode.Attr {
      // regexp for Label will be `{{ Label }}`
      re := regexp.MustCompile(fmt.Sprintf(`\{\{\s*%s\s*\}\}`, attr.Key()))
      content = re.ReplaceAllString(content, attr.Val())
    }

    ch.domNode.Set("textContent", content)
  }

* DEMO

* What is not there

- Nested components
- No branching in DSL (if-else)
- No loops in DSL
- This is just a demo :)

* Conclusion

Go on WASM

- It works
- It's not perfect
- Please give it a try!
- Yay!

# vim: ts=2:sts=2:sw=2:expandtab
