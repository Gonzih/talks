GOing to WASM?
Should we be excited? What is possible?

18 Oct 2018

Max Gonzih

https://gonzih.me
gonzih@gmail.com
@Gonzih

* What is WASM?

.html tweaks.html

.image webassembly.svg _ 800

* What is WASM?
- binary instruction format
- stack-based VM
- targeting web and server side deployments

* Why does it matter?

- less JavaScript on the Web
- less transpilers
- almost native level of performance

* Possibilities

Using WebAssembly on a serverless platform

[[https://blog.cloudflare.com/webassembly-on-cloudflare-workers/][https://blog.cloudflare.com/webassembly-on-cloudflare-workers/]]

* Possibilities

Kernel Mode WebAssembly Runtime for Linux

[[https://github.com/rianhunter/wasmjit][https://github.com/rianhunter/wasmjit]]

> Wasmjit is a small embeddable WebAssembly runtime. Its core is written in C90 and is easily portable to most environments.


* Running Go on WASM

- Available since 1.11
- Adds `GOOS=js` and `GOARCH=wasm` variables to the compiler
- Interop is implemented using `syscall/js` package

.image packagejs.png

* Getting JS helper

  curl https://raw.githubusercontent.com/golang/go/go1.11/misc/wasm/wasm_exec.js > wasm_exec.js

Or

  cp $GOSRC/misc/wasm/wasm_exec.js wasm_exec.js

* JS helper

`wasm_exec.js`

- Unifies Node.js and browser WASM APIs in to one JS object called Go
- Sets up JS -> Go interop

  const setInt64 = (addr, v) => {
    mem().setUint32(addr + 0, v, true);
    mem().setUint32(addr + 4, Math.floor(v / 4294967296), true);
  }

* JS helper

`wasm_exec.js`

- Sets up funcs from `syscall/js` pagkage on Go side

  // func valueGet(v ref, p string) ref
  "syscall/js.valueGet": (sp) => {
    storeValue(sp + 32, Reflect.get(loadValue(sp + 8), loadString(sp + 16)));
  },


* Getting HTML template

  curl https://raw.githubusercontent.com/golang/go/go1.11/misc/wasm/wasm_exec.html > wasm_exec.html

Or

  cp $GOSRC/misc/wasm/wasm_exec.html wasm_exec.html

* Getting HTML template

`wash_exec.html` Demonstrates how to put this together

- on JS side

  const go = new Go();
  ...
  WebAssembly.instantiateStreaming(...).then((result) => {
      mod = result.module;
      inst = result.instance;

  });

  async function run() {
    await go.run(inst);
    ...
  }

- and HTML side

  <button onClick="run();" id="runButton" disabled>Run</button>

* Hello World time

  package main

  import "syscall/js"

  func main() {
    js.Global().Call("alert", "Hello Wasm!")
  }

* Compiling it

  GOARCH=wasm GOOS=js go build -o test.wasm

* Running it

Well, *test.wasm* needs to be loaded with Content-Type header set to *application/wasm*

What shall we do?

* Let's put together a small file server

.code server.go

* DEMO

* The Future is here

.image wasm-corp.png _ 800


* Should we be excited?

Yes, but...

* But...

  $ l -lha test.wasm
  -rwxr-xr-x 1 gnzh gnzh 2.4M Sep 15 09:13 test.wasm*

* Why?

- WASM is a stack mahcine. Go has to maintain its own stack (GC)
- No GOTO instruction, so Go has to generate a huge switch statement to resume goroutines
- Binary size was not a priority for this release

[[https://docs.google.com/document/d/131vjr4DH6JFnb-blm_uRdaC0_Nv3OUwjEY5qVCxCup4/edit][WebAssembly architecture for GO]]

* Going crazy

[[https://github.com/Gonzih/wasm-components-go][https://github.com/Gonzih/wasm-components-go]]

* UI Components in Go

- Attempt to create something Vue.js inspired

* Use <template> tag as our templating solution

    <template id="rootTemplate">
        <div>
            <a href="http://google.com" target="_blank">Hello</a> world!
        </div>
    </template>

* Parse <template> HTML using net/html

    template, err := dom.GetInnerHTMLByID(templateID)
    r := strings.NewReader(cmp.Template)
    z := html.NewTokenizer(r)

    tt := z.Next()
    switch {
    ...
    case tt == html.StartTagToken:
      el := &El{}
      el.Type = token.Data
      for _, attr := range token.Attr {
        ...
      }
      ...
    }

* Handle text nodes

   case tt == html.TextToken:
     t := z.Token()
     child := &El{Type: TEXT_TYPE, NodeValue: t.Data}
     el.Children = append(parent.Children, child)

* State stored in Store

* Subscriptions using reflections on components

* Components generate VDOM
	vdom := cmp.RenderToVDom()
	vdom.Diff(cmp.OldVDom, &changes)

* VDOM can be rendered to string
* VDOM can be diffed to generate changeset
* Changeset can be executed to modify real dom

<template>
</template>

# vim: ts=2:sts=2:sw=2:expandtab
